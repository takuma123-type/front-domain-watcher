{"ast":null,"code":"import { Storage } from \"../infrastructure/Storage\";\nimport { InvlalidSessionTokenError, UnauthorizedError, UsersRepository } from \"../infrastructure/repositories\";\nexport class FetchUsersInput {}\nexport class FetchUsersOutput {\n  constructor(params) {\n    this.users = void 0;\n    this.users = params.users;\n  }\n}\nexport class FetchUsersUsecase {\n  async fetch() {\n    const sessionToken = Storage.restoreSessionToken();\n    if (!sessionToken) {\n      throw new InvlalidSessionTokenError();\n    }\n    const usersRepository = new UsersRepository();\n    try {\n      const usersData = await usersRepository.fetch(sessionToken);\n      const usersList = usersData.map(user => ({\n        id: user.id,\n        firstName: user.name.split(\" \")[0],\n        lastName: user.name.split(\" \")[1] || \"\",\n        attribute: user.status,\n        email: user.email\n      }));\n      return new FetchUsersOutput({\n        users: usersList\n      });\n    } catch (error) {\n      if (error instanceof UnauthorizedError) {\n        Storage.clear();\n      }\n      throw error;\n    }\n  }\n}","map":{"version":3,"names":["Storage","InvlalidSessionTokenError","UnauthorizedError","UsersRepository","FetchUsersInput","FetchUsersOutput","constructor","params","users","FetchUsersUsecase","fetch","sessionToken","restoreSessionToken","usersRepository","usersData","usersList","map","user","id","firstName","name","split","lastName","attribute","status","email","error","clear"],"sources":["/usr/src/app/admin_front/src/usecases/FetchUsersUsecase.tsx"],"sourcesContent":["import { Storage } from \"../infrastructure/Storage\";\nimport {\n  InvlalidSessionTokenError,\n  UnauthorizedError,\n  UsersRepository,\n} from \"../infrastructure/repositories\";\nimport { UserItem } from \"../models/presentation/UserItem\";\n\nexport class FetchUsersInput {}\n\nexport class FetchUsersOutput {\n  readonly users: UserItem[];\n\n  constructor(params: { users: UserItem[] }) {\n    this.users = params.users;\n  }\n}\n\nexport class FetchUsersUsecase {\n  async fetch(): Promise<FetchUsersOutput> {\n    const sessionToken = Storage.restoreSessionToken();\n    if (!sessionToken) {\n      throw new InvlalidSessionTokenError();\n    }\n\n    const usersRepository = new UsersRepository();\n\n    try {\n      const usersData = await usersRepository.fetch(sessionToken);\n      const usersList = usersData.map((user: any) => ({\n        id: user.id,\n        firstName: user.name.split(\" \")[0],\n        lastName: user.name.split(\" \")[1] || \"\",\n        attribute: user.status,\n        email: user.email,\n      }));\n\n      return new FetchUsersOutput({ users: usersList });\n    } catch (error) {\n      if (error instanceof UnauthorizedError) {\n        Storage.clear();\n      }\n      throw error;\n    }\n  }\n}\n"],"mappings":"AAAA,SAASA,OAAO,QAAQ,2BAA2B;AACnD,SACEC,yBAAyB,EACzBC,iBAAiB,EACjBC,eAAe,QACV,gCAAgC;AAGvC,OAAO,MAAMC,eAAe,CAAC;AAE7B,OAAO,MAAMC,gBAAgB,CAAC;EAG5BC,WAAWA,CAACC,MAA6B,EAAE;IAAA,KAFlCC,KAAK;IAGZ,IAAI,CAACA,KAAK,GAAGD,MAAM,CAACC,KAAK;EAC3B;AACF;AAEA,OAAO,MAAMC,iBAAiB,CAAC;EAC7B,MAAMC,KAAKA,CAAA,EAA8B;IACvC,MAAMC,YAAY,GAAGX,OAAO,CAACY,mBAAmB,CAAC,CAAC;IAClD,IAAI,CAACD,YAAY,EAAE;MACjB,MAAM,IAAIV,yBAAyB,CAAC,CAAC;IACvC;IAEA,MAAMY,eAAe,GAAG,IAAIV,eAAe,CAAC,CAAC;IAE7C,IAAI;MACF,MAAMW,SAAS,GAAG,MAAMD,eAAe,CAACH,KAAK,CAACC,YAAY,CAAC;MAC3D,MAAMI,SAAS,GAAGD,SAAS,CAACE,GAAG,CAAEC,IAAS,KAAM;QAC9CC,EAAE,EAAED,IAAI,CAACC,EAAE;QACXC,SAAS,EAAEF,IAAI,CAACG,IAAI,CAACC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;QAClCC,QAAQ,EAAEL,IAAI,CAACG,IAAI,CAACC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE;QACvCE,SAAS,EAAEN,IAAI,CAACO,MAAM;QACtBC,KAAK,EAAER,IAAI,CAACQ;MACd,CAAC,CAAC,CAAC;MAEH,OAAO,IAAIpB,gBAAgB,CAAC;QAAEG,KAAK,EAAEO;MAAU,CAAC,CAAC;IACnD,CAAC,CAAC,OAAOW,KAAK,EAAE;MACd,IAAIA,KAAK,YAAYxB,iBAAiB,EAAE;QACtCF,OAAO,CAAC2B,KAAK,CAAC,CAAC;MACjB;MACA,MAAMD,KAAK;IACb;EACF;AACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}